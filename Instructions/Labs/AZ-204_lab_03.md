---
lab:
    az204Title: '实验室 03：使用适用于 .NET 的 Azure 存储 SDK 检索 Azure 存储资源和元数据'
    az020Title: '实验室 03：使用适用于 .NET 的 Azure 存储 SDK 检索 Azure 存储资源和元数据'
    az204Module: '模块 03：开发使用 Blob 存储的解决方案'
    az020Module: '模块 03：开发使用 Blob 存储的解决方案'
---

# 实验室 03：使用适用于 .NET 的 Azure 存储 SDK 检索 Azure 存储资源和元数据

## Microsoft Azure 用户界面

鉴于 Microsoft 云工具的动态特性，Azure 用户界面 (UI) 在此培训内容开发后可能会发生更改。因此，实验室说明和实验室步骤可能无法完全一致。

当社区提醒我们进行必要的更改时，Microsoft 会更新本培训课程。然而，云更新的发生频率很高，因此你可能会遇到 UI 已更改但本培训内容尚未更新的情况。**如果发生这种情况，请适应这些更改，并根据需要在实验室中熟悉这些更改。**

## 说明

### 准备工作

#### 登录实验室环境

使用以下凭据登录 Windows 10 虚拟机 (VM)：

-   用户名：**Admin**

-   密码： **Pa55w.rd**

> **备注**：你的讲师将提供连接到虚拟实验室环境的说明。

#### 查看已安装的应用程序

在你的 Windows 10 桌面上找到任务栏。任务栏里有本实验室中你将使用的应用程序的图标，包括：

-   Microsoft Edge

-   文件资源管理器

## 体系结构图

![该体系结构图描述用户使用适用于 .NET 的 Azure 存储 SDK 检索 Azure 存储资源和元数据。](./media/Lab03-Diagram.png)

### 练习 1：创建 Azure 资源

#### 任务 1：打开 Azure 门户

1.  在任务栏上，选择 **Microsoft Edge** 图标。

1. 在浏览器窗口中，浏览到 Azure 门户 (<https://portal.azure.com>)，然后使用你将在本实验室中使用的帐户登录。

   > **备注**：第一次登录 Azure 门户时，你会看到一个门户教程。选择“**开始使用**”，跳过教程并开始使用门户。

#### 任务 2：创建存储帐户

1.  在 Azure 门户中，使用“**搜索资源、服务和文档**”文本框搜索“**存储帐户**”，然后在结果列表中选择“**存储帐户**”。

1.  在“**存储帐户**”边栏选项卡中，选择“**+ 创建**”。

1.  在“**创建存储帐户**”边栏选项卡上的“**基本信息**”选项卡上，执行以下操作，然后选择“**查看 + 创建**”：

   | 设置                           | 操作                                                       |
   | --------------------------------- | ------------------------------------------------------------ |
   | “**订阅**”下拉列表   | 保留默认值。                                    |
   | “**资源组**”部分        | 选择“**新建**”，输入 **StorageMedia**，然后选择“**确定**”。 |
   | “**存储帐户名称**”文本框 | 输入“**mediastor**_[yourname]_”。                             |
   | “**区域**”下拉列表         | 选择“**(美国)美国东部**”。                                     |
   | “**性能**”部分           | 选择“**标准**”选项。                              |
   | “**冗余**”下拉列表     | 选择“**本地冗余存储(LRS)**”。                  |

   以下屏幕截图显示了“**创建存储帐户**”边栏选项卡中的已配置设置。
 
   ![“创建存储帐户”边栏选项卡](./media/l03_create_a_storage_account.png)
   
1.  在“**查看 + 创建**”选项卡中，查看在上述步骤中选择的选项。

1.  选择“**创建**”，使用指定的配置创建存储帐户。

    > **备注**：等待创建任务完成，再继续本实验室。

1.  选择“**前往资源**”。

1.  在“**存储帐户**”边栏选项卡上的“**设置**”部分中，选择“**终结点**”链接。

1.  在“**终结点**”部分，记录“**Blob 服务**”文本框的值。

    > **备注**：你将在稍后的实验室中使用此终结点值。

1.  在“**存储帐户**”边栏选项卡的“**安全性 + 网络**”部分，选择“**访问密钥**”链接。

1.  在“**访问密钥**”部分中，执行以下操作：

    a.  记录“**存储帐户名**”文本框中的值。
    
    b.  选择“**显示密钥**”。

    c.  选择任一密钥，然后记录任一“**密钥**”框中的值。

    > **备注**：你将在本实验室的后面部分使用所有这些值。

#### 回顾

在本练习中，你创建了将用于本实验室其余部分的新存储帐户。

### 练习 2： 将 Blob 上传到容器

#### 任务 1：创建存储帐户容器

1. 在“**存储帐户**”边栏选项卡中，选择“**数据存储**”部分的“**容器**”链接。

1. 在“**容器**”部分，选择“**+ 容器**”。

1. 在“**新建容器**”弹出窗口中，执行以下操作，然后选择“**创建**”：

    | 设置                                | 操作                                    |
    | -------------------------------------- | ----------------------------------------- |
    | “**名称**”文本框                      | 输入“**raster-graphics**”。                |
    | “**公共访问级别**”下拉列表 | 选择“**专用(无匿名访问)**”。 |

1. 在“**容器**”部分，选择“**+ 容器**”。

1. 在“**新建容器**”弹出窗口中，执行以下操作，然后选择“**创建**”：

    | 设置                                | 操作                                    |
    | -------------------------------------- | ----------------------------------------- |
    | “**名称**”文本框                      | 输入“**compressed-audio**”。               |
    | “**公共访问级别**”下拉列表 | 选择“**专用(无匿名访问)**”。 |

1. 在“**容器**”部分中，查看容器更新列表。

    以下屏幕截图显示了“**创建存储帐户**”边栏选项卡中的已配置设置。

    ![“创建存储帐户”边栏选项卡](./media/l03_containers.png)

#### 任务 2：上传存储帐户 Blob

1.  在“**容器**”部分中，选择最近创建的 **raster-graphics** 容器。

1.	在“**容器**”边栏选项卡中，选择“**上传**”。

1.	在“**上传 Blob**”窗口中，执行以下操作，然后选择“**上传**”：

   | 设置                           | 操作                                                       |
   | --------------------------------- | ------------------------------------------------------------ |
   | “**文件**”部分   | 选择“**文件夹**”图标。                                    |
   | “**文件资源管理器**”窗口        | 浏览到 **Allfiles (F):\\Allfiles\\Labs\\03\\Starter\\Images**，选择 **graph.jpg** 文件，然后选择“**打开**”。 |
   | “**如果文件已存在，请覆盖**”复选框 | 确保选中此复选框。                        |
   
   > **备注**： 等待 Blob 上传完成，然后再继续本实验室。

#### 回顾

在本练习中，你在存储帐户中创建了占位符容器，并在其中一个容器中填充了一个 Blob。

### 练习 3： 使用 .NET SDK 访问容器

#### 任务 1：创建 .NET 项目

1.  在“**启动**”屏幕上，选择“**Visual Studio Code**”磁贴。

1.  在“**文件**”菜单中，选择“**打开文件夹**”，浏览到 **Allfiles (F):\\Allfiles\\Labs\\03\\Starter\\BlobManager**，然后选择“**选择文件夹**”。

1.  在 **Visual Studio Code** 窗口中，激活“**资源管理器**”窗格的快捷菜单，然后选择“**在集成终端中打开**”。

1.  在命令提示符下，运行以下命令，在当前文件夹中创建一个名为 **BlobManager** 的新 .NET 项目：

    ```
    dotnet new console --name BlobManager --output .
    ```

    > **备注**： **dotnet new** 命令将在与项目同名的文件夹中创建一个的**控制**台项目。

1.  在命令提示符下，运行以下命令，从 NuGet 导入 12.0.0 版本的 **Azure.Storage.Blobs**：

    ```
    dotnet add package Azure.Storage.Blobs --version 12.0.0
    ```

    > **备注**： **dotnet add package** 命令将从 NuGet 添加 **Azure.Storage.Blobs** 包。有关详细信息，请参阅 [Azure.Storage.Blobs](https://www.nuget.org/packages/Azure.Storage.Blobs/12.0.0)。

1.  在命令提示符下，运行以下命令，构建 .NET Web 应用程序：

    ```
    dotnet build
    ```

1.  选择“**终止终端**”或者“**回收站**”图标以关闭当前打开的终端和所有关联的进程。

#### 任务 2：修改程序类以访问存储

1.  在 **Visual Studio Code** 窗口的“**资源管理器**”窗格中，打开 **Program.cs** 文件。

1.  在 **Program.cs** 文件的代码编辑器选项卡中，删除现有文件中的所有代码。

1.  添加以下代码行，从 **Azure.Storage.Blobs** 包（从 NuGet 中导入）中导入 **Azure.Storage**、**Azure.Storage.Blobs** 和 **Azure.Storage.Blobs.Models** 命名空间：

    ```csharp
    using Azure.Storage;
    using Azure.Storage.Blobs;
    using Azure.Storage.Blobs.Models;
    ```
    
1.  添加以下代码行，为此文件将使用的内置命名空间添加 **using** 指令：

    ```csharp
    using System;
    using System.Threading.Tasks;
    ```

1.  输入以下代码，创建一个新的 **Program** 类：

    ```csharp
    public class Program
    {
    }
    ```

1.  在 **Program** 类中，输入以下代码行，创建一个名为 **blobServiceEndpoint** 的新字符串常量：

    ```csharp
    private const string blobServiceEndpoint = "";
    ```

1.  通过将 **blobServiceEndpoint** 字符串常量的值设置为之前在本实验室中记录的存储帐户的“**主 Blob 服务终结点**”来更新该字符串常量。

1.  在 **Program** 类中，输入以下代码行，创建一个名为 **storageAccountName** 的新字符串常量：

    ```csharp
    private const string storageAccountName = "";
    ```

1.  通过将 **storageAccountName** 字符串常量的值设置为之前在本实验室中记录的存储帐户的**存储帐户名**称来更新该字符串常量。

1.  在 **Program** 类中，输入以下代码行，创建一个名为 **storageAccountKey** 的新字符串常量：

    ```csharp
    private const string storageAccountKey = "";
    ```

1.  通过将 **storageAccountKey** 字符串常量的值设置为之前在本实验室中记录的存储帐户的**密钥**来更新该字符串常量。

1.  在 **Program** 类中，输入以下代码以创建新的异步 **Main** 方法：

    ```csharp
    public static async Task Main(string[] args)
    {
    }
    ```

1.  查看 **Program.cs** 文件，该文件现在应包括：

    ```csharp
    using Azure.Storage;
    using Azure.Storage.Blobs;
    using Azure.Storage.Blobs.Models;
    using System;
    using System.Threading.Tasks;
    
    public class Program
    {
        private const string blobServiceEndpoint = "<primary-blob-service-endpoint>";
        private const string storageAccountName = "<storage-account-name>";
        private const string storageAccountKey = "<key>";
    
        public static async Task Main(string[] args)
        {
        }
    }
    ```

#### 任务 3：连接到 Azure 存储 Blob 服务终结点

1.  在 **Main** 方法中，使用 **storageAccountName** 和 **storageAccountKey** 常量作为构造函数参数，添加以下代码行，创建新的 **StorageSharedKeyCredential** 实例：

    ```csharp
    StorageSharedKeyCredential accountCredentials = new StorageSharedKeyCredential(storageAccountName, storageAccountKey);
    ```

1.  在 **Main** 方法中，使用 **blobServiceEndpoint** 常量和 *accountCredentials* 变量作为构造函数参数添加以下代码行，创建新的 **BlobServiceClient** 类实例：

    ```csharp
    BlobServiceClient serviceClient = new BlobServiceClient(new Uri(blobServiceEndpoint), accountCredentials);
    ```

1.  在 **Main** 方法中，添加以下代码行，调用 **BlobServiceClient** 类的 **GetAccountInfoAsync** 方法，从服务中检索帐户元数据：

    ```csharp
    AccountInfo info = await serviceClient.GetAccountInfoAsync();
    ```
    
1.  在 **Main** 方法中，添加以下代码行，呈现欢迎消息：

    ```csharp
    await Console.Out.WriteLineAsync($"Connected to Azure Storage Account");
    ```
    
1.  在 **Main** 方法中，添加以下代码行，以呈现存储帐户名称：

    ```csharp
    await Console.Out.WriteLineAsync($"Account name:\t{storageAccountName}");
    ```
    
1.  在 **Main** 方法中，添加以下代码行以呈现存储帐户类型：

    ```csharp
    await Console.Out.WriteLineAsync($"Account kind:\t{info?.AccountKind}");
    ```
    
1.  在 **Main** 方法中，添加以下代码行，以呈现当前为存储帐户选择的库存单位 (SKU)：

    ```
    await Console.Out.WriteLineAsync($"Account sku:\t{info?.SkuName}");
    ```

1.  查看 **Main** 方法，其中现在应包括：

    ```csharp
    public static async Task Main(string[] args)
    {
        StorageSharedKeyCredential accountCredentials = new StorageSharedKeyCredential(storageAccountName, storageAccountKey);

        BlobServiceClient serviceClient = new BlobServiceClient(new Uri(blobServiceEndpoint), accountCredentials);

        AccountInfo info = await serviceClient.GetAccountInfoAsync();

        await Console.Out.WriteLineAsync($"Connected to Azure Storage Account");
        await Console.Out.WriteLineAsync($"Account name:\t{storageAccountName}");
        await Console.Out.WriteLineAsync($"Account kind:\t{info?.AccountKind}");
        await Console.Out.WriteLineAsync($"Account sku:\t{info?.SkuName}");
    }
    ```

1.  保存 **Program.cs** 文件。

1.  在 **Visual Studio Code** 窗口中，激活“**资源管理器**”窗格的快捷菜单，然后选择“**在集成终端中打开**”。

1.  在打开的命令提示符下，运行以下命令，以运行 .NET Web 应用程序：

    ```
    dotnet run
    ```

    > **备注**：如果出现任何生成错误，请查看位于 **Allfiles (F):\\Allfiles\\Labs\\03\\Solution\\BlobManager** 文件夹中的 **Program.cs** 文件。

1.  观察当前运行的控制台应用程序的输出。输出包含从服务中检索到的存储帐户的元数据。

1.  选择“**终止终端**”或者“**回收站**”图标以关闭当前打开的终端和所有关联的进程。

#### 任务 4：枚举现有容器

1.  在 **Program** 类中，输入以下代码，创建名为 **EnumerateContainersAsync** 的新**私有静态**异步方法，该方法只有一个 **BlobServiceClient** 参数类型：

    ```csharp
    private static async Task EnumerateContainersAsync(BlobServiceClient client)
    {        
    }
    ```

1.  在 **EnumerateContainersAsync** 方法中，输入以下代码，创建异步 **foreach** 循环，对 **BlobServiceClient** 类的 **GetBlobContainersAsync** 方法的调用结果进行迭代：

    ```csharp
    await foreach (BlobContainerItem container in client.GetBlobContainersAsync())
    {
    }
    ```

1.  在 **foreach** 循环中，输入以下代码，打印每个容器的名称：

    ```csharp
    await Console.Out.WriteLineAsync($"Container:\t{container.Name}");
    ```

1.  查看 **EnumerateContainersAsync** 方法，该方法现在应包括：

    ```csharp
    private static async Task EnumerateContainersAsync(BlobServiceClient client)
    {        
        await foreach (BlobContainerItem container in client.GetBlobContainersAsync())
        {
            await Console.Out.WriteLineAsync($"Container:\t{container.Name}");
        }
    }
    ```

1.  在 **Main** 方法中，请在方法末尾输入以下代码以调用 **EnumerateContainersAsync** 方法，传入 *serviceClient* 变量作为参数：

    ```csharp
    await EnumerateContainersAsync(serviceClient);
    ```

1.  查看 **Main** 方法，该方法现在应包括：

    ```csharp
    public static async Task Main(string[] args)
    {
        // Existing code has not been repeated here for brevity

        await EnumerateContainersAsync(serviceClient);
    }
    ```

1.  保存 **Program.cs** 文件。

1.  在 **Visual Studio Code** 窗口中，激活“**资源管理器**”窗格的快捷菜单，然后选择“**在集成终端中打开**”。

1.  在打开的命令提示符下，运行以下命令，以运行 .NET Web 应用程序：

    ```
    dotnet run
    ```

    > **备注**：如果出现任何生成错误，请查看位于 **Allfiles (F):\\Allfiles\\Labs\\03\\Solution\\BlobManager** 文件夹中的 **Program.cs** 文件。

1.  观察当前运行的控制台应用程序的输出。更新后的输出包括帐户中每个现有容器的列表。

1.  选择“**终止终端**”或者“**回收站**”图标以关闭当前打开的终端和所有关联的进程。

#### 回顾

在本练习中，使用 Azure 存储 SDK 访问现有容器。

### 练习 4： 使用 .NET SDK 检索 Blob 统一资源标识符 (URI)

#### 任务 1： 使用 SDK 枚举现有容器中的 Blob

1.  在 **Program** 类中，输入以下代码，以创建名为 **EnumerateBlobsAsync** 的新**私有静态**异步方法，该方法具有两种参数类型，即 **BlobServiceClient** 和 **string**：

    ```csharp
    private static async Task EnumerateBlobsAsync(BlobServiceClient client, string containerName)
    {      
    }
    ```

1.  在 **EnumerateBlobsAsync** 方法中，输入以下代码，使用 **BlobServiceClient** 类的 **GetBlobContainerClient** 方法获取 **BlobContainerClient** 类的新实例，从而传入 **containerName** 参数：

    ```csharp
    BlobContainerClient container = client.GetBlobContainerClient(containerName);
    ```

1.  在 **EnumerateBlobsAsync** 方法中，输入以下代码，以呈现将枚举的容器的名称：

    ```csharp
    await Console.Out.WriteLineAsync($"Searching:\t{container.Name}");
    ```

1.  在 **EnumerateBlobsAsync** 方法中，输入以下代码，以创建异步 **foreach** 循环，该循环对 **BlobContainerClient** 类的 **GetBlobsAsync** 方法的调用结果进行循环访问：

    ```csharp
    await foreach (BlobItem blob in container.GetBlobsAsync())
    {        
    }
    ```

1.  在 **foreach** 循环中，输入以下代码，以打印每个 Blob 的名称：

    ```csharp
     await Console.Out.WriteLineAsync($"Existing Blob:\t{blob.Name}");
    ```

1.  查看 **EnumerateBlobsAsync** 方法，该方法现在应包括：

    ```csharp
    private static async Task EnumerateBlobsAsync(BlobServiceClient client, string containerName)
    {      
        BlobContainerClient container = client.GetBlobContainerClient(containerName);
        
        await Console.Out.WriteLineAsync($"Searching:\t{container.Name}");
        
        await foreach (BlobItem blob in container.GetBlobsAsync())
        {        
             await Console.Out.WriteLineAsync($"Existing Blob:\t{blob.Name}");
        }
    }
    ```

1.  在 **Main** 方法中，在方法末尾输入以下代码，创建一个名为 *existingContainerName* 且值为 **raster-graphics** 的变量：

    ```csharp
    string existingContainerName = "raster-graphics";
    ```

1.  在 **Main** 方法中，在方法末尾输入以下代码以调用 **EnumerateBlobsAsync** 方法，从而传入 *serviceClient* 和 *existingContainerName* 变量作为参数：

    ```csharp
    await EnumerateBlobsAsync(serviceClient, existingContainerName);
    ```

1.  查看 **Main** 方法，该方法现在应包括：

    ```csharp
    public static async Task Main(string[] args)
    {
        // Existing code has not been repeated here for brevity
        
        await EnumerateContainersAsync(serviceClient);

        string existingContainerName = "raster-graphics";
        await EnumerateBlobsAsync(serviceClient, existingContainerName);
    }
    ```

1.  保存 **Program.cs** 文件。

1.  在 **Visual Studio Code** 窗口中，激活“**资源管理器**”窗格的快捷菜单，然后选择“**在集成终端中打开**”。

1.  在打开的命令提示符下，运行以下命令，以运行 .NET Web 应用程序：

    ```
    dotnet run
    ```

    > **备注**：如果出现任何生成错误，请查看位于 **Allfiles (F):\\Allfiles\\Labs\\03\\Solution\\BlobManager** 文件夹中的 **Program.cs** 文件。

1.  查看当前运行的控制台应用程序的输出。更新后的输出包括有关现有容器和 Blob 的元数据。

1.  选择“**终止终端**”或者“**回收站**”图标以关闭当前打开的终端和所有关联的进程。

#### 任务 2： 使用 SDK 创建新容器

1.  在 **Program** 类中输入以下代码，创建名为 **GetContainerAsync** 的新**私有静态**异步方法，该方法有两种参数类型，即 **BlobServiceClient** 和 **string**：

    ```csharp
    private static async Task<BlobContainerClient> GetContainerAsync(BlobServiceClient client, string containerName)
    {      
    }
    ```

1.  在 **GetContainerAsync** 方法中，输入以下代码，使用 **BlobServiceClient** 类的 **GetBlobContainerClient** 方法获取 **BlobContainerClient** 类的新实例，并传入 **containerName** 参数：

    ```csharp
    BlobContainerClient container = client.GetBlobContainerClient(containerName);
    ```

1.  在 **GetContainerAsync** 方法中，输入以下代码，调用 **BlobContainerClient** 类的 **CreateIfNotExistsAsync** 方法：

    ```csharp
    await container.CreateIfNotExistsAsync(PublicAccessType.Blob);
    ```

1.  在 **GetContainerAsync** 方法中输入以下代码，呈现可能创建的容器的名称：

    ```csharp
    await Console.Out.WriteLineAsync($"New Container:\t{container.Name}");
    ```

1.  在 **GetContainerAsync** 方法中，输入以下代码，返回名为 **container** 的 **BlobContainerClient** 类的实例，作为 **GetContainerAsync** 方法的结果：

    ```csharp
    return container;
    ```

1.  查看 **GetContainerAsync** 方法，该方法现在应包括：

    ```csharp
    private static async Task<BlobContainerClient> GetContainerAsync(BlobServiceClient client, string containerName)
    {      
        BlobContainerClient container = client.GetBlobContainerClient(containerName);
        
        await container.CreateIfNotExistsAsync(PublicAccessType.Blob);
        
        await Console.Out.WriteLineAsync($"New Container:\t{container.Name}");
        
        return container;
    }
    ```

1.  在 **Main** 方法中，在方法末尾输入以下代码，创建一个名为 *newContainerName* 且值为 **vector-graphics** 的变量：

    ```csharp
    string newContainerName = "vector-graphics";
    ```

1.  在 **Main** 方法中，在方法末尾输入以下代码以调用 **GetContainerAsync** 方法，从而以参数的形式传递 *serviceClient* 和 *newContainerName* 变量，并将结果存储在名为 *containerClient* 的 **BlobContainerClient** 类型的变量中：

    ```csharp
    BlobContainerClient containerClient = await GetContainerAsync(serviceClient, newContainerName);
    ```

1.  查看 **Main** 方法，其中现在应包括：

    ```csharp
    public static async Task Main(string[] args)
    {
        // Existing code has not been repeated here for brevity
        
        await EnumerateContainersAsync(serviceClient);

        string existingContainerName = "raster-graphics";
        await EnumerateBlobsAsync(serviceClient, existingContainerName);
        
        string newContainerName = "vector-graphics";
        BlobContainerClient containerClient = await GetContainerAsync(serviceClient, newContainerName);
    }
    ```

1.  保存 **Program.cs** 文件。

1.  在 **Visual Studio Code** 窗口中，激活“**资源管理器**”窗格的快捷菜单，然后选择“**在集成终端中打开**”。

1.  在打开的命令提示符下，运行以下命令，以运行 .NET Web 应用程序：

    ```
    dotnet run
    ```

    > **备注**：如果出现任何生成错误，请查看位于 **Allfiles (F):\\Allfiles\\Labs\\03\\Solution\\BlobManager** 文件夹中的 **Program.cs** 文件。

1.  观察当前运行的控制台应用程序的输出。更新后的输出包括有关现有容器和 Blob 的元数据。

1.  选择“**终止终端**”或者“**回收站**”图标以关闭当前打开的终端和所有关联的进程。

#### 任务 3：使用门户上传新 Blob

1.  在 Azure 门户的“**导航**”窗格中，选择“**资源组**”链接。

1.  在“**资源组**”边栏选项卡上，选择你在本实验室前面部分创建的“**StorageMedia**”资源组。

1.  在“**StorageMedia**”边栏选项卡中，选择你之前在本实验室中创建的 **mediastor**_[yourname]_ 存储帐户。

1.  在“**存储帐户**”边栏选项卡中，选择“**数据存储**”部分的“**容器**”链接。

1.  在“**容器**”部分中，选择新创建的 **vector-graphics** 容器。可能需要刷新页面才能看到新的容器。

1.	在“**容器**”边栏选项卡中，选择“**上传**”。

1.	在“**上传 Blob**”窗口中，执行以下操作，然后选择“**上传**”：

    | 设置                           | 操作                                                       |
    | --------------------------------- | ------------------------------------------------------------ |
    | “**文件**”部分   | 选择“**文件夹**”图标。                                    |
    | “**文件资源管理器**”窗口        |  **Allfiles (F):\\Allfiles\\Labs\\03\\Starter\\Images**，选择 **graph.svg** 文件，然后选择“**打开**”。 |
    | “**如果文件已存在，请覆盖**”复选框 | 确保选中此复选框。                        |

    > **备注**：等待 Blob 上传完成，然后再继续本实验室。

#### 任务 4：使用 SDK 访问 Blob URI

1.  切换到“**Visual Studio Code**”窗口。

1.  在 **Program** 类中，输入以下代码，创建名为 **GetBlobAsync** 的新**私有静态**异步方法。该方法具有两种参数类型，即 **BlobContainerClient** 和 **string**：

    ```csharp
    private static async Task<BlobClient> GetBlobAsync(BlobContainerClient client, string blobName)
    {      
    }
    ```

1.  在 **GetBlobAsync** 方法中，输入以下代码以使用 **BlobContainerClient** 类的 **GetBlobClient** 方法获取 **BlobClient** 类的新实例，从而传入 **blobName** 参数：

    ```csharp
    BlobClient blob = client.GetBlobClient(blobName);
    ```

1.  在 **GetBlobAsync** 方法中，输入以下代码，呈现所引用的 Blob 的名称：

    ```csharp
    await Console.Out.WriteLineAsync($"Blob Found:\t{blob.Name}");
    ```

1.  在 **GetBlobAsync** 方法中，输入以下代码，返回名为 **blob** 的 **BlobClient** 类实例，作为 **GetBlobAsync** 方法的结果：

    ```csharp
    return blob;
    ```

1.  查看 **GetBlobAsync** 方法，该方法现在应包括：

    ```csharp
    private static async Task<BlobClient> GetBlobAsync(BlobContainerClient client, string blobName)
    {      
        BlobClient blob = client.GetBlobClient(blobName);
        await Console.Out.WriteLineAsync($"Blob Found:\t{blob.Name}");
        return blob;
    }
    ```

1.  在 **Main** 方法中，在方法末尾输入以下代码，创建一个名为 *uploadedBlobName* 且值为 **graph.svg** 的变量：

    ```csharp
    string uploadedBlobName = "graph.svg";
    ```

1.  在 **Main** 方法中，在方法末尾输入以下代码以调用 **GetBlobAsync** 方法，从而以参数的形式传入 *containerClient* 和 *uploadedBlobName* 变量，并将结果存储在名为 *blobClient* 的 **BlobClient** 类变量中：

    ```csharp
    BlobClient blobClient = await GetBlobAsync(containerClient, uploadedBlobName);
    ```

1.  在 **Main** 方法中，在方法末尾输入以下代码，呈现 *blobClient* 变量的 **Uri** 属性：

    ```csharp
    await Console.Out.WriteLineAsync($"Blob Url:\t{blobClient.Uri}");
    ```

1.  查看 **Main** 方法，该方法现在应包括：

    ```csharp
    public static async Task Main(string[] args)
    {
        // Existing code has not been repeated here for brevity
        
        await EnumerateContainersAsync(serviceClient);

        string existingContainerName = "raster-graphics";
        await EnumerateBlobsAsync(serviceClient, existingContainerName);
        
        string newContainerName = "vector-graphics";
        BlobContainerClient containerClient = await GetContainerAsync(serviceClient, newContainerName);
        
        string uploadedBlobName = "graph.svg";
        BlobClient blobClient = await GetBlobAsync(containerClient, uploadedBlobName);

        await Console.Out.WriteLineAsync($"Blob Url:\t{blobClient.Uri}");
    }
    ```

1.  保存 **Program.cs** 文件。

1.  在 **Visual Studio Code** 窗口中，激活“**资源管理器**”窗格的快捷菜单，然后选择“**在集成终端中打开**”。

1.  在打开的命令提示符下，运行以下命令，以运行 .NET Web 应用程序：

    ```
    dotnet run
    ```

    > **备注**：如果出现任何生成错误，请查看位于 **Allfiles (F):\\Allfiles\\Labs\\03\\Solution\\BlobManager** 文件夹中的 **Program.cs** 文件。

1.  观察当前运行的控制台应用程序的输出。更新后的输出包括用于在线访问 Blob 的最终 URL。记录本 URL 的值，以便稍后在本实验室中使用。

    > **备注**：该 URL 将类似以下字符串： `https://mediastor*[yourname]*.blob.core.windows.net/vector-graphics/graph.svg`

1.  选择“**终止终端**”或者“**回收站**”图标以关闭当前打开的终端和所有关联的进程。

#### 任务 5：使用浏览器测试该 URI

1.  在任务栏中，激活“**Microsoft Edge**”图标的快捷菜单，然后选择“**新建窗口**”。

1.  在新的浏览器窗口中，参阅之前在本实验室中为 Blob 复制的 URL。

1.  现在，你应该会在浏览器窗口中看到可缩放矢量图形 (SVG) 文件。

#### 回顾

在本练习中，你使用存储 SDK 创建了容器并管理了 Blob。

### 练习 5：清理订阅

#### 任务 1：打开 Azure Cloud Shell 并列出资源组

1.  在 Azure 门户中，选择 **Cloud Shell** 图标 ![Cloud Shell 图标](./media/az204_lab_CloudShell.png)，打开新的 Bash 会话。如果 Cloud Shell 默认为 PowerShell 会话，请选择“**PowerShell**”，然后在下拉菜单中选择“**Bash**”。

    > **备注**：首次启动 **Cloud Shell** 时，系统会提示选择 **Bash** 或 **PowerShell**，请选择“**PowerShell**”。如果显示“**未挂载存储**”消息，请选择你在本实验室中使用的订阅，然后选择“**创建存储**”。

#### 任务 2：删除资源组

1.  在 **Cloud Shell** 窗格中运行以下命令，以删除“**StorageMedia**”资源组：

    ```
    az group delete --name StorageMedia --no-wait --yes
    ```
     > **备注**：该命令以异步方式执行（由 *--no-wait* 参数确定），因此，尽管可立即在同一 Bash 会话中运行另一个 Azure CLI 命令，但实际上要花几分钟才能删除资源组。

1. 关闭门户中的 **Cloud Shell** 窗格。

#### 任务 3：关闭活动的应用程序

- 关闭当前正在运行的 Microsoft Edge 应用程序。

#### 回顾

在本练习中，你通过删除本实验室中使用的资源组清理了订阅。
