---
lab:
    az204Title: '实验室 10：使用 Azure 服务总线队列异步处理消息'
    az020Title: '实验室 10：使用 Azure 服务总线队列异步处理消息'
    az204Module: '模块 10：开发基于消息的解决方案'
    az020Module: '模块 10：开发基于消息的解决方案'
---

# 实验室 10： 使用 Azure 服务总线队列异步处理消息

## Microsoft Azure 用户界面

鉴于 Microsoft 云工具的动态特性，Azure UI 在此培训内容开发后可能会发生更改。因此，实验室说明和实验室步骤可能无法完全一致。

当社区提醒我们进行必要的更改时，Microsoft 会更新本培训课程。然而，云更新的发生频率很高，因此你可能会遇到 UI 已更改但本培训内容尚未更新的情况。**如果发生这种情况，请适应这些更改，并根据需要在实验室中熟悉这些更改。**

## 说明

### 准备工作

#### 登录实验室环境

使用以下凭据登录 Windows 10 虚拟机 (VM)：
    
-   用户名：**Admin**

-   密码：**Pa55w.rd**

> **备注**：你的讲师将提供连接到虚拟实验室环境的说明。

#### 查看已安装的应用程序

在你的 Windows 10 桌面上找到任务栏。任务栏里有本实验室中你将使用的应用程序的图标，包括：
    
-   Microsoft Edge

-   Visual Studio Code

## 体系结构图

![描绘用户使用 Azure 服务总线队列异步处理消息的体系结构图](./media/Lab10-Diagram.png)

### 练习 1：创建 Azure 资源

#### 任务 1：打开 Azure 门户

1.  在任务栏上，选择 **Microsoft Edge** 图标。

1.  在浏览器窗口中，浏览到 Azure 门户 ([portal.azure.com](https://portal.azure.com))，并使用在本实验室中你将使用的帐户进行登录。

    > **备注**：第一次登录 Azure 门户时，你会看到一个门户教程。选择“**开始使用**”，跳过教程并开始使用门户。

#### 任务 2：创建 Azure 服务总线队列

1.  在 Azure 门户中，使用“**搜索资源、服务和文档**”文本框搜索“**服务总线**”，然后在结果列表中选择“**服务总线**”。

1.  在“**服务总线**”边栏选项卡上，选择“**+ 创建**”。

1.  在“**创建命名空间**”边栏选项卡上的“**基本信息**”选项卡上，执行以下操作，然后选择“**查看 + 创建**”：
        
    | 设置                           | 操作                                                       |
    | --------------------------------- | ------------------------------------------------------------ |
    | “**订阅**”下拉列表    |保留默认值。 |
    | “**资源组**”部分 | 选择“**新建**”，输入 **AsyncProcessor**，然后选择“**确定**”。|
    | “**命名空间名称**”文本框 | 输入 **sbnamespace**_[yourname]_。|
    | “**区域**”下拉列表 |  选择可以在其中部署 Azure 服务总线的任何 Azure 区域。|
    | “**定价层**”下拉列表 |  选择“**基本**”。|

    以下屏幕截图显示了“**创建命名空间**”边栏选项卡上“**基本信息**”选项卡上的已配置设置。
    
       ![“创建 Azure 服务总线命名空间”边栏选项卡](./media/l10_create_sb_namespace.png)
     
1.  在“**查看 + 创建**”选项卡中，查看在上述步骤中选择的选项。

1.  选择“**创建**”以使用指定的配置创建“**服务总监**”命名空间。

    > **备注**：等待创建任务完成，再继续本实验室。

1.  在“**部署**”边栏选项卡上，选择“**前往资源**”按钮以导航到新创建的“**服务总线**”命名空间的边栏选项卡。

1.  在“**服务总线**”命名空间边栏选项卡的“**设置**”部分，选择“**共享访问策略**”。

1.  在策略列表中，选择 **RootManageSharedAccessKey**。

1.  在“**SAS 策略: RootManageSharedAccessKey**”窗格中，在**主连接字符串**条目旁边，选择“**复制到剪贴板**”按钮，并记录复制的值。本实验室后面会用到它。

    > **备注**：可任意选择两个可用键中的一个。它们可以互换。

1.  在“**服务总线**”命名空间边栏选项卡的“**实体**”部分，选择“**队列**”，然后选择“**+ 队列**”。

1.  在“**创建队列**”边栏选项卡上，查看可用设置，在“**名称**”文本框中，输入 **messagequeue**，然后选择“**创建**”。

1.  选择 **messagequeue** 以显示“**服务总线**”队列的属性。

1.  使浏览器窗口保持打开状态。本实验室后面会再次用到它。

#### 回顾

在本练习中，你创建了一个 Azure **服务总线**命名空间和一个**服务总线**队列，本实验室的其余部分会用到它们。

### 练习 2：创建 .NET Core 项目以将消息发布到服务总线队列

#### 任务 1：创建 .NET Core 项目

1.  在实验室计算机上，启动 Visual Studio Code。

1.  在 Visual Studio Code 的“**文件**”菜单中，选择“**打开文件夹**”。

1.  在“**打开文件夹**”窗口中，浏览到 **Allfiles (F):\\Allfiles\\Labs\\10\\Starter\\MessagePublisher**，然后选择“**选择文件夹**”。

1.  在 **Visual Studio Code** 窗口中，激活快捷菜单，然后选择“**在集成终端中打开**”。

1.  在终端提示符下，运行以下命令，在当前文件夹中创建一个名为 **MessagePublisher** 的新 .NET 项目：

    ```
    dotnet new console --name MessagePublisher --output .
    ```

    > **备注**： **dotnet new** 命令将在与项目同名的文件夹中创建一个新的**控制**台项目。

1.  运行以下命令，从 NuGet 导入 7.2.1 版 **Azure.Messaging.ServiceBus** 包：

    ```
    dotnet add package Azure.Messaging.ServiceBus --version 7.2.1
    ```

    > **备注**： **dotnet add package** 命令将从 NuGet 添加 **Azure.Messaging.ServiceBus** 包。有关详细信息，请前往 [Azure.Messaging.ServiceBus](https://www.nuget.org/packages/Azure.Messaging.ServiceBus/)。

1.  在终端提示符下，运行以下命令，构建 .NET Core 控制台应用程序：

    ```
    dotnet build
    ```

1.  选择“**终止终端**”（“**回收站**”图标）以关闭终端窗格和所有关联进程。

#### 任务 2：将消息发布到 Azure 服务总线队列

1.  在 **Visual Studio Code** 窗口的“**资源管理器**”窗格中，打开 **Program.cs** 文件。

1.  在“**Program.cs**”文件的代码编辑器选项卡中，删除现有文件中的所有代码。

1.  添加以下代码行，以便使用此文件中将引用的内置命名空间：

    ```csharp
    using System;
    using System.Threading.Tasks;
    ```

1.  添加以下代码，导入从 NuGet 导入的 **Azure.Storage.Queues** 包中包含的 **Azure.Messaging.ServiceBus** 命名空间：

    ```csharp
    using Azure.Messaging.ServiceBus;
    ```
    
1.  输入以下代码，在 **MessagePublisher** 命名空间中创建一个新的 **Program** 类：

    ```csharp
    namespace MessagePublisher
    {
       public class Program
       {
       }
    }
    ```

1.  在 **Program** 类中，输入以下代码，创建名为 **storageConnectionString** 的字符串常量：

    ```csharp
    private const string storageConnectionString = "";
    ```

1.  更新 **storageConnectionString** 字符串常量，将其值设置为你在本实验室前面部分记录的服务总线命名空间的**主连接字符串**。

1.  输入以下代码，创建一个名为 **queueName** 的字符串常量，其值为 **messagequeue**，与你在本练习前面部分创建的服务总线队列的名称一致。

    ```csharp
    private const string queueName = "messagequeue";
    ```

1.  输入以下代码，创建一个整数常量，用于存储要发送到目标队列的消息数：

    ```csharp
    private const int numOfMessages = 3;
    ```

1.  输入以下代码，创建用于与目标队列建立连接的服务总线客户端：

    ```csharp
    static ServiceBusClient client;
    ```

1.  输入以下代码，创建用于将消息发布到目标队列的服务总线发送方：

    ```csharp
    static ServiceBusSender sender;
    ```

1.  输入以下代码，创建异步 **Main** 方法：

    ```csharp
    public static async Task Main(string[] args)
    {
    }
    ```

1.  查看 **Program.cs** 文件，该文件中现在应该包含以下代码行。请注意，`<storage-connection-string>` 占位符表示到目标 Azure 服务总线命名空间的连接字符串：

    ```csharp
    using System;
    using System.Threading.Tasks;
    using Azure.Messaging.ServiceBus;

    namespace MessagePublisher
    {
        public class Program
        {
            private const string storageConnectionString = "<storage-connection-string>";
            private const string queueName = "messagequeue";
            private const int numOfMessages = 3;

            static ServiceBusClient client;
            static ServiceBusSender sender;

            public static async Task Main(string[] args)
            {
            }
        }
    }
    ```

1.  在 **Main** 方法中，添加以下代码，初始化 **ServiceBusClient** 类型的*客户*端（用于与服务总线命名空间建立连接）和**发送方**（负责发送消息）：

    ```csharp
    client = new ServiceBusClient(storageConnectionString);
    sender = client.CreateSender(queueName);  
    ```

    > **备注**：在应用程序的整个生命周期中，服务总线客户端可以安全地缓存并用作单一实例。这被认为是定期发布和阅读消息的其中一种最佳做法。

1.  在 **Main** 方法中，添加以下代码，创建一个 **ServiceBusMessageBatch** 对象，借助该对象，你可以使用 **TryAddMessage** 方法将多条消息合并为一个批处理：

    ```csharp        
    using ServiceBusMessageBatch messageBatch = await sender.CreateMessageBatchAsync();
    ```

1.  在 **Main** 方法中，添加以下代码行，将消息添加到批处理中，并在消息大小超过批处理支持的限制时引发异常：

    ```csharp        
    for (int i = 1; i <= numOfMessages; i++)
    {
        if (!messageBatch.TryAddMessage(new ServiceBusMessage($"Message {i}")))
        {
            throw new Exception($"The message {i} is too large to fit in the batch.");
        }
    }
    ```

1.  在 **Main** 方法中，添加以下代码行，创建一个 try 块，让**发送方**将批处理中的消息异步发布到目标队列：

    ```csharp        
    try
    {
        await sender.SendMessagesAsync(messageBatch);
        Console.WriteLine($"A batch of {numOfMessages} messages has been published to the queue.");
    }

1.  在 **Main** 方法中，添加以下代码行，创建一个 finally 块，以异步处理**发送方**和**客户**端对象，释放任何网络和非托管资源：

    ```csharp
    finally
    {
        await sender.DisposeAsync();
        await client.DisposeAsync();
    }
    ```

1.  查看 **Main** 方法，该方法中现在应该包含以下代码： 

    ```csharp
    public static async Task Main(string[] args)
    {
        client = new ServiceBusClient(storageConnectionString);
        sender = client.CreateSender(queueName);

        using ServiceBusMessageBatch messageBatch = await sender.CreateMessageBatchAsync();

        for (int i = 1; i <= numOfMessages; i++)
        {
            if (!messageBatch.TryAddMessage(new ServiceBusMessage($"Message {i}")))
            {
                throw new Exception($"The message {i} is too large to fit in the batch.");
            }
        }

        try
        {
            await sender.SendMessagesAsync(messageBatch);
            Console.WriteLine($"A batch of {numOfMessages} messages has been published to the queue.");
        }
        finally
        {
            await sender.DisposeAsync();
            await client.DisposeAsync();
        }
    }
    ```

1.  保存 **Program.cs** 文件。

1.  在 **Visual Studio Code** 窗口中，激活快捷菜单，然后选择“**在集成终端中打开**”。

1.  在终端提示符下，运行以下命令，启动 .NET Core 控制台应用：

    ```
    dotnet run
    ```

    > **备注**：如果遇到任何错误，请查看 **Allfiles (F):\\Allfiles\\Labs\\10\\Solution\\MessagePublisher** 文件夹中的 **Program.cs** 文件。

1.  验证终端提示符下显示的控制台消息是否表明已将三条消息的批处理发布到队列中。

1.  选择“**终止终端**”（“**回收站**”图标）以关闭终端窗格和所有关联进程。

1.  切换到 Microsoft Edge 浏览器，在 Azure 门户中显示服务总线队列 **messagequeue**。

1.  查看“**概要**”窗格并注意队列包含三条活动消息。

    以下屏幕截图显示了服务总线队列指标和消息计数。
     
       ![Azure 门户中的服务总线队列指标和消息计数](./media/l10_display_queue_with_messages_portal.png)
     
1.  在“**设置**”部分，选择“**服务总线资源管理器(预览版)**”。

1.  在“**服务总线资源管理器(预览版)**”边栏选项卡上，选择“**速览**”选项卡标题，然后在“**速览**”选项卡上，选择“**速览**”按钮。

1.  验证队列是否包含三条消息。

1.  选择第一条消息并在“**消息**”窗格中查看其内容。

    以下屏幕截图显示了第一条消息的内容。
         
       ![服务总线资源管理器中的服务总线队列内容](./media/l10_peek_queue_with_messages_explorer.png)

     
1.  关闭“**消息**”窗格。

#### 回顾

在本练习中，你配置了将消息发布到 Azure 服务总线队列的 .NET 项目。

### 练习 3：创建 .NET Core 项目以从服务总线队列读取消息

#### 任务 1：创建 .NET 项目

1.  在实验室计算机上，启动 Visual Studio Code。

1.  在 Visual Studio Code 的“**文件**”菜单中，选择“**打开文件夹**”。

1.  在“**打开文件夹**”窗口中，浏览到 **Allfiles (F):\\Allfiles\\Labs\\10\\Starter\\MessageReader**，然后选择“**选择文件夹**”。

1.  在 **Visual Studio Code** 窗口中，激活快捷菜单，然后选择“**在集成终端中打开**”。

1.  在终端提示符下，运行以下命令，在当前文件夹中创建一个名为 **MessageReader** 的新 .NET 项目：

    ```
    dotnet new console --name MessageReader --output .
    ```

1.  运行以下命令，从 NuGet 导入 7.2.1 版 **Azure.Messaging.ServiceBus** 包：

    ```
    dotnet add package Azure.Messaging.ServiceBus --version 7.2.1
    ```

1.  在终端提示符下，运行以下命令，构建 .NET Core 控制台应用程序：

    ```
    dotnet build
    ```

1.  选择“**终止终端**”（“**回收站**”图标）以关闭终端窗格和所有关联进程。

#### 任务 2： 从 Azure 服务总线队列读取消息

1.  在 **Visual Studio Code** 窗口的“**资源管理器**”窗格中，打开 **Program.cs** 文件。

1.  在“**Program.cs**”文件的代码编辑器选项卡中，删除现有文件中的所有代码。

1.  添加 Program.cs 文件中包含的相同代码，允许与 Azure 服务总线队列交互，但将命名空间设置为 **MessageReader**：

    ```csharp
    using System;
    using System.Threading.Tasks;
    using Azure.Messaging.ServiceBus;
    
    namespace MessageReader
    {
       public class Program
       {
          private const string storageConnectionString = "";
          static string queueName = "messagequeue";
          static ServiceBusClient client;

       }
    }
    ```

1.  与之前一样，更新 **storageConnectionString** 字符串常量，将其值设置为你在本实验室前面部分记录的**服务总线**命名空间的**主连接字符串**。

1.  输入以下代码，创建用于处理队列中消息的 ServiceBusProcessor：

    ```csharp
    static ServiceBusProcessor processor;
    ```

1.  输入以下代码，创建静态异步 **MessageHandler** 任务，以在处理队列中的消息时显示消息正文，并在处理完成后删除正文：

    ```csharp
    static async Task MessageHandler(ProcessMessageEventArgs args)
    {
        string body = args.Message.Body.ToString();
        Console.WriteLine($"Received: {body}");
        await args.CompleteMessageAsync(args.Message);
    }
    ```

1.  输入以下代码，创建静态异步 **ErrorHandler** 任务，以管理在处理消息的过程中遇到的任何异常：

    ```csharp
    static Task ErrorHandler(ProcessErrorEventArgs args)
    {
        Console.WriteLine(args.Exception.ToString());
        return Task.CompletedTask;
    }
    ```

1.  输入以下代码，创建异步 **Main** 方法：

    ```csharp
    public static async Task Main(string[] args)
    {
    }
    ```

1.  查看 **Program.cs** 文件，该文件中现在应该包含以下代码行。`<storage-connection-string>` 占位符表示到目标 Azure 服务总线命名空间的连接字符串：

    ```csharp
    using System;
    using System.Threading.Tasks;
    using Azure.Messaging.ServiceBus;

    namespace MessageReader
    {
        class Program
        {
            static string storageConnectionString = "";
            static string queueName = "messagequeue";
            static ServiceBusClient client;
            static ServiceBusProcessor processor;

            static async Task MessageHandler(ProcessMessageEventArgs args)
            {
                string body = args.Message.Body.ToString();
                Console.WriteLine($"Received: {body}");
                await args.CompleteMessageAsync(args.Message);
            }

            static Task ErrorHandler(ProcessErrorEventArgs args)
            {
                Console.WriteLine(args.Exception.ToString());
                return Task.CompletedTask;
            }

            static async Task Main()
            {
            }
        }
    }
    ```

1.  在 **Main** 方法中，添加以下代码，初始化 **ServiceBusClient** 类型的*客户*端（用于与服务总线命名空间建立连接）和**处理方**（负责处理消息）：

    ```csharp
    client = new ServiceBusClient(storageConnectionString);
    processor = client.CreateProcessor(queueName, new ServiceBusProcessorOptions());
    ```

    > **备注**：如前所述，在应用程序的整个生命周期中，服务总线客户端可以安全地缓存并用作单一实例。这被认为是定期发布和阅读消息的其中一种最佳做法。

1.  在 **Main** 方法中，添加以下代码行，创建一个 try 块，以先实现消息和错误处理处理程序，启动消息处理，然后根据用户输入停止处理：

    ```csharp        
    try
    {
        processor.ProcessMessageAsync += MessageHandler;
        processor.ProcessErrorAsync += ErrorHandler;

        await processor.StartProcessingAsync();
        Console.WriteLine("Wait for a minute and then press any key to end the processing");
        Console.ReadKey();

        Console.WriteLine("\nStopping the receiver...");
        await processor.StopProcessingAsync();
        Console.WriteLine("Stopped receiving messages");
    }

1.  在 **Main** 方法中，添加以下代码行，创建一个 finally 块，以异步处理**处理方**和**客户**端对象，释放任何网络和非托管资源：

    ```csharp
    finally
    {
        await processor.DisposeAsync();
        await client.DisposeAsync();
    }
    ```

1.  查看 **Main** 方法，该方法中现在应该包含以下代码：

    ```csharp
    static async Task Main()
    {
        client = new ServiceBusClient(storageConnectionString);
        processor = client.CreateProcessor(queueName, new ServiceBusProcessorOptions());

        try
        {
            processor.ProcessMessageAsync += MessageHandler;
            processor.ProcessErrorAsync += ErrorHandler;

            await processor.StartProcessingAsync();
            Console.WriteLine("Wait for a minute and then press any key to end the processing");
            Console.ReadKey();

            Console.WriteLine("\nStopping the receiver...");
            await processor.StopProcessingAsync();
            Console.WriteLine("Stopped receiving messages");
        }
        finally
        {
            await processor.DisposeAsync();
            await client.DisposeAsync();
        }
    }
    ```

1.  保存 **Program.cs** 文件。

1.  在 **Visual Studio Code** 窗口中，激活快捷菜单，然后选择“**在集成终端中打开**”。

1.  在终端提示符下，运行以下命令，启动 .NET Core 控制台应用：

    ```
    dotnet run
    ```

    > **备注**：如果遇到任何错误，请查看 **Allfiles (F):\\Allfiles\\Labs\\10\\Solution\\MessageReader** 文件夹中的 **Program.cs** 文件。

1.  验证终端提示符下显示的控制台消息是否表明队列中的三条消息均已收到。

1.  在终端提示符下，按任意键停止接收方并终止应用执行。

1.  选择“**终止终端**”（“**回收站**”图标）以关闭终端窗格和所有关联进程。

1.  切换回 Microsoft Edge 浏览器，在 Azure 门户中显示服务总线队列 **messagequeue**。

1.  在“**服务总线资源管理器(预览版)**”边栏选项卡上，选择“**刷新**”，并注意队列中的活动消息数是否已更改为 **0**。

#### 回顾

在本练习中，你使用 .NET 库从 Azure 服务总线队列读取和删除了消息。

### 练习 4：清理订阅

#### 任务 1：打开 Azure Cloud Shell

1.  在 Azure 门户中，选择 **Cloud Shell** 图标 ![Cloud Shell 图标](./media/az204_lab_CloudShell.png)，打开新的 Bash 会话。如果 Cloud Shell 默认为 PowerShell 会话，请选择“**PowerShell**”，然后在下拉菜单中选择“**Bash**”。

    > **备注**：首次启动 **Cloud Shell** 时，系统会提示选择 **Bash** 或 **PowerShell**，请选择“**PowerShell**”。如果显示“**未挂载存储**”消息，请选择你在本实验室中使用的订阅，然后选择“**创建存储**”。

#### 任务 2：删除资源组

1.  在 **Cloud Shell** 窗格中，运行以下命令，删除 **AsyncProcessor** 资源组：

    ```
    az group delete --name AsyncProcessor --no-wait --yes
    ```
    
     > **备注**：该命令以异步方式执行（由 *--no-wait* 参数确定），因此，尽管可立即在同一 Bash 会话中运行另一个 Azure CLI 命令，但实际上要花几分钟才能删除资源组。
  
1.  关闭门户中的 **Cloud Shell** 窗格。

#### 任务 3：关闭活动应用程序

1.  关闭当前正在运行的 Microsoft Edge 应用程序。

1.  关闭当前正在运行的“Visual Studio Code”应用程序。

#### 回顾

在本练习中，你通过删除本实验室中使用的资源组清理订阅。
